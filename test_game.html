<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Medieval Mini RPG</title>
<style>
  body { margin: 0; background: #111; color: white; font-family: sans-serif; text-align: center; overflow: hidden; }
  #hud { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; font-size: 18px; align-items: center; }
  canvas { background: black; display: block; margin: auto; }
  .bar { background: #333; width: 200px; height: 20px; border-radius: 10px; overflow: hidden; }
  .bar-fill { height: 100%; background: limegreen; }
</style>
</head>
<body>
<h1>‚öîÔ∏è Medieval Mini RPG</h1>
<div id="hud">
  <div class="bar"><div id="hp-fill" class="bar-fill"></div></div>
  <div id="hp-text">HP 100/100</div>
  <div id="gold">üí∞ 0</div>
  <div id="wave">Wave 1</div>
  <div id="level">Lvl 1</div>
</div>
<canvas id="game" width="960" height="600"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const WIDTH = canvas.width;
const HEIGHT = canvas.height;
const TILE = 32;

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function rand(a, b) { return Math.random() * (b - a) + a; }
function dist2(x1, y1, x2, y2) { return (x1 - x2) ** 2 + (y1 - y2) ** 2; }

function generateMap(cols, rows) {
  const map = Array.from({ length: rows }, () => Array(cols).fill(0));
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (x === 0 || y === 0 || x === cols - 1 || y === rows - 1) map[y][x] = 1;
    }
  }
  for (let i = 0; i < Math.floor((cols * rows) / 14); i++) {
    map[Math.floor(rand(2, rows - 2))][Math.floor(rand(2, cols - 2))] = 2;
  }
  for (let i = 0; i < 10; i++) {
    const rx = Math.floor(rand(2, cols - 2));
    const ry = Math.floor(rand(2, rows - 2));
    if (map[ry][rx] === 0) map[ry][rx] = 3;
  }
  return map;
}

function isBlocked(map, nx, ny) {
  const cols = map[0].length;
  const rows = map.length;
  if (nx < 0 || ny < 0 || nx > WIDTH || ny > HEIGHT) return true;
  const gx = Math.floor(nx / TILE);
  const gy = Math.floor(ny / TILE);
  const tile = map[clamp(gy, 0, rows - 1)][clamp(gx, 0, cols - 1)];
  return tile === 1 || tile === 2 || tile === 3;
}

function drawMap(ctx, map) {
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[0].length; x++) {
      const t = map[y][x];
      const px = x * TILE;
      const py = y * TILE;
      ctx.fillStyle = (x + y) % 2 ? "#2c3e1f" : "#324a23";
      ctx.fillRect(px, py, TILE, TILE);
      if (t === 1) { ctx.fillStyle = "#4b545e"; ctx.fillRect(px, py, TILE, TILE); }
      if (t === 2) { ctx.fillStyle = "#2a3b16"; ctx.beginPath(); ctx.arc(px + TILE / 2, py + TILE / 2, TILE / 2.4, 0, Math.PI * 2); ctx.fill(); }
      if (t === 3) { ctx.fillStyle = "#214b75"; ctx.fillRect(px, py, TILE, TILE); }
    }
  }
}

function makePlayer(x, y) { return { x, y, r: 13, speed: 2.5, dir: { x: 1, y: 0 }, hp: 100, maxHp: 100, gold: 0, attack: { cooldown: 0, windup: 0, range: 35, arc: Math.PI / 2 }, invincible: 0, level: 1, xp: 0 }; }
function makeEnemy(x, y, tier = 1) { return { tier, hp: tier === 1 ? 20 : tier === 2 ? 40 : 80, speed: tier === 1 ? 1.5 : tier === 2 ? 1.3 : 1.0, dmg: tier === 1 ? 8 : tier === 2 ? 12 : 20, r: tier === 1 ? 12 : tier === 2 ? 14 : 16, color: tier === 1 ? "#7d2b2b" : tier === 2 ? "#7d5a2b" : "#5b2b7d", x, y, knock: 0 }; }
function makeHeart(x, y) { return { type: "heart", x, y, r: 6, ttl: 9000 }; }
function makeGold(x, y, amount) { return { type: "gold", x, y, r: 5, ttl: 12000, amount }; }

function swordArc(player) {
  const { x, y, attack, dir } = player;
  const ang = Math.atan2(dir.y, dir.x);
  const a0 = ang - attack.arc / 2;
  const a1 = ang + attack.arc / 2;
  const r = attack.range;
  return [ { x, y }, { x: x + Math.cos(a0) * r, y: y + Math.sin(a0) * r }, { x: x + Math.cos(a1) * r, y: y + Math.sin(a1) * r } ];
}

function pointInTri(px, py, a, b, c) {
  const v0x = c.x - a.x, v0y = c.y - a.y;
  const v1x = b.x - a.x, v1y = b.y - a.y;
  const v2x = px - a.x, v2y = py - a.y;
  const dot00 = v0x * v0x + v0y * v0y;
  const dot01 = v0x * v1x + v0y * v1y;
  const dot02 = v0x * v2x + v0y * v2y;
  const dot11 = v1x * v1x + v1y * v1y;
  const dot12 = v1x * v2x + v1y * v2y;
  const invDen = 1 / (dot00 * dot11 - dot01 * dot01);
  const u = (dot11 * dot02 - dot01 * dot12) * invDen;
  const v = (dot00 * dot12 - dot01 * dot02) * invDen;
  return u >= 0 && v >= 0 && u + v <= 1;
}

const cols = Math.floor(WIDTH / TILE);
const rows = Math.floor(HEIGHT / TILE);
const map = generateMap(cols, rows);
const player = makePlayer(WIDTH / 2, HEIGHT / 2);
let enemies = [];
let drops = [];
let lastSpawn = 0;
let wave = 1;
let time = 0;

const keys = new Set();
window.addEventListener("keydown", e => { if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," ","Space","w","a","s","d","W","A","S","D"].includes(e.key)) e.preventDefault(); keys.add(e.key); });
window.addEventListener("keyup", e => keys.delete(e.key));

function spawnEnemyRing(count, tier = 1) {
  for (let i = 0; i < count; i++) {
    const angle = (i / count) * Math.PI * 2;
    const r = Math.min(WIDTH, HEIGHT) / 2 - 40;
    const ex = WIDTH / 2 + Math.cos(angle) * r;
    const ey = HEIGHT / 2 + Math.sin(angle) * r;
    enemies.push(makeEnemy(ex, ey, tier));
  }
}

function update(dt) {
  const dx = (keys.has("ArrowRight") || keys.has("d") || keys.has("D")) - (keys.has("ArrowLeft") || keys.has("a") || keys.has("A"));
  const dy = (keys.has("ArrowDown") || keys.has("s") || keys.has("S")) - (keys.has("ArrowUp") || keys.has("w") || keys.has("W"));
  let mag = Math.hypot(dx, dy) || 1;
  const vx = (dx / mag) * player.speed * (dt / 16.67);
  const vy = (dy / mag) * player.speed * (dt / 16.67);
  if (dx || dy) player.dir = { x: dx / mag, y: dy / mag };
  let nx = clamp(player.x + vx, 0, WIDTH);
  let ny = clamp(player.y + vy, 0, HEIGHT);
  if (!isBlocked(map, nx, player.y)) player.x = nx;
  if (!isBlocked(map, player.x, ny)) player.y = ny;
  player.attack.cooldown = Math.max(0, player.attack.cooldown - dt);
  player.attack.windup = Math.max(0, player.attack.windup - dt);
  const attackPressed = keys.has(" ") || keys.has("Space");
  if (attackPressed && player.attack.cooldown === 0 && player.attack.windup === 0) { player.attack.windup = 150; player.attack.cooldown = 500; }
  if (player.attack.windup > 0 && player.attack.windup < 50) {
    const tri = swordArc(player);
    enemies.forEach(e => { if (pointInTri(e.x, e.y, tri[0], tri[1], tri[2])) { e.hp -= 15 + player.level * 2; e.knock = 120; e.x += player.dir.x * 8; e.y += player.dir.y * 8; }});
  }
  enemies = enemies.filter(e => e.hp > 0);
  enemies.forEach(e => {
    if (e.knock > 0) { e.knock -= dt; return; }
    const dx = player.x - e.x; const dy = player.y - e.y; const d = Math.hypot(dx, dy) || 1;
    const sp = e.speed * (dt / 16.67);
    const nx = e.x + (dx / d) * sp; const ny = e.y + (dy / d) * sp;
    if (!isBlocked(map, nx, e.y)) e.x = nx;
    if (!isBlocked(map, e.x, ny)) e.y = ny;
    const minDist = (e.r + player.r) * 0.9;
    if (dist2(e.x, e.y, player.x, player.y) < minDist * minDist && player.invincible <= 0) { player.hp -= e.dmg; player.invincible = 600; }
  });
  player.invincible = Math.max(0, player.invincible - dt);
  drops = drops.filter(d => (d.ttl -= dt) > 0);
  drops.forEach(d => {
    const reach = d.r + player.r + 2;
    if (dist2(d.x, d.y, player.x, player.y) < reach * reach) {
      if (d.type === "heart") player.hp = Math.min(player.maxHp, player.hp + 20);
      else if (d.type === "gold") { player.gold += d.amount; player.xp += d.amount / 2; }
      d.ttl = -1;
    }
  });
  drops = drops.filter(d => d.ttl > 0);
  lastSpawn += dt;
  if (lastSpawn > 10000) { lastSpawn = 0; wave++; const tier = wave < 4 ? 1 : wave < 7 ? 2 : 3; spawnEnemyRing(4 + Math.min(10, wave * 2), tier); }
  if (Math.random() < 0.01) { const side = Math.floor(rand(0, 4)); const ex = side % 2 === 0 ? (side === 0 ? 10 : WIDTH - 10) : rand(10, WIDTH - 10); const ey = side % 2 === 1 ? (side === 1 ? 10 : HEIGHT - 10) : rand(10, HEIGHT - 10); enemies.push(makeEnemy(ex, ey, wave >= 6 ? 2 : 1)); }
  const newDrops = [];
  enemies.forEach(e => { if (e.hp <= 0 && Math.random() < 0.9) { if (Math.random() < 0.35) newDrops.push(makeHeart(e.x, e.y)); newDrops.push(makeGold(e.x, e.y, Math.floor(rand(4, 10)))); }});
  drops.push(...newDrops);
  const xpToNext = 50 + (player.level - 1) * 40;
  if (player.xp >= xpToNext) { player.level++; player.xp -= xpToNext; player.maxHp += 10; player.hp = player.maxHp; player.attack.cooldown = Math.max(250, player.attack.cooldown - 20); }
  document.getElementById("hp-fill").style.width = `${(player.hp/player.maxHp)*100}%`;
  document.getElementById("hp-text").innerText = `HP ${Math.max(0,Math.floor(player.hp))}/${player.maxHp}`;
  document.getElementById("gold").innerText = `üí∞ ${player.gold}`;
  document.getElementById("wave").innerText = `Wave ${wave}`;
  document.getElementById("level").innerText = `Lvl ${player.level}`;
}

function render() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);
  drawMap(ctx, map);
  drops.forEach(d => { ctx.fillStyle = d.type === "heart" ? "#c0392b" : "#c9a227"; ctx.beginPath(); ctx.arc(d.x, d.y, d.r, 0, Math.PI * 2); ctx.fill(); });
  enemies.forEach(e => { ctx.fillStyle = e.color; ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2); ctx.fill(); });
  ctx.fillStyle = "#95a5a6"; ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2); ctx.fill();
}

let lastTime = 0;
function gameLoop(ts) {
  if (!lastTime) lastTime = ts;
  const dt = ts - lastTime;
  lastTime = ts;
  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}

spawnEnemyRing(5);
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
